import{e}from"./app.140fd78c.js";import{_ as n}from"./plugin-vue_export-helper.5a098b48.js";const a={},s=e('<h1 id="自定义表达式内函数" tabindex="-1"><a class="header-anchor" href="#自定义表达式内函数" aria-hidden="true">#</a> 自定义表达式内函数</h1><blockquote><p>翻译自原文档：https://osdn.net/projects/emuera/wiki/UserMeth</p></blockquote><p>表达式内函数，即除了内置函数之外，还可以在表达式中调用<code>@~~</code>中定义的函数。</p><p>关于表达式内函数的更多信息，<a href="">请参见表达式内函数</a>。</p><h2 id="格式" tabindex="-1"><a class="header-anchor" href="#格式" aria-hidden="true">#</a> 格式</h2><p>被调用的函数必须有<code>#FUNCTION</code>或<code>#FUNCTIONS</code>标志，并且必须以<code>RETURNF</code>结束。</p><p><code>#FUNCTION</code>表示该函数返回一个数字。</p><p><code>#FUNCTION(S)</code>：返回一个字符串。</p><p>一个带有<code>#FUNCTION(S)</code>的函数不能用通常的<code>RETURN</code>来终止。 相反，它们是以<code>RETURNF</code>终止的。</p><p><code>RETURNF</code>可以是一个公式或一个字符串表达式。 它必须符合<code>#FUNCTION(S)</code>中给出的类型。</p><p>如果省略<code>RETURNF</code>参数，或者在没有<code>RETURNF</code>的情况下到达函数的终点，则返回<code>0</code>或<code>&quot;&quot;</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>X = GET_CFLAG(TARGET, Y)\nSTR = %GET_NAME(TARGET)%\n\n@GET_CFLAG(ARG:0, ARG:1)\n#FUNCTION\n  SIF ARG:0 &lt;= 0 || ARG:0 &gt;= CHARANUM\n    RETURNF 0\n  RETURNF CFLAG:(ARG:0):(ARG:1)\n\n@GET_NAME(ARG:0)\n#FUNCTIONS\n  SIF ARG:0 &lt;= 0 || ARG:0 &gt;= CHARANUM\n    RETURNF &quot;&quot;\n  RETURNF NAME:(ARG:0)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>函数定义的参数用<code>()</code>括起来，但这不是定义的必要语法。</p><p>如果你想在表达式中调用一个函数，你需要使用带<code>()</code>的语法。</p><p>你也可以用逗号把函数名和参数分开，就像你对普通函数那样。</p><p>下面两行的意思是一样的：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>@GET_CFLAG(ARG:0, ARG:1)\n@GET_CFLAG, ARG, ARG:1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也可以为参数设置初始值。</p><p>关于初始值的语法的更多信息，请参阅在你自己的<a href="">函数中指定参数</a>。</p><h2 id="限制条件" tabindex="-1"><a class="header-anchor" href="#限制条件" aria-hidden="true">#</a> 限制条件</h2><h3 id="不能从call中调用" tabindex="-1"><a class="header-anchor" href="#不能从call中调用" aria-hidden="true">#</a> 不能从CALL中调用</h3><p>带有<code>FUNCTION(S)</code>标志的函数不能以通常的方式调用，例如<code>CALL</code>。</p><p>它只能在一个表达式中被调用。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>;错误\nCALL GET_CFLAG, X, Y\n\n@GET_CFLAG(ARG:0, ARG:1)\n#FUNCTION\n  SIF ARG:0 &lt;= 0 || ARG:0 &gt;= CHARANUM\n    RETURNF 0\n  RETURNF CFLAG:(ARG:0):(ARG:1)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>#FUNCTION(S)</code>可以从<code>CALLF</code>和<code>CALLFORMF</code>中调用，它们是调用<code>FUNCTION(S)</code>的专用指令。</p><h3 id="有些指令是不可用的" tabindex="-1"><a class="header-anchor" href="#有些指令是不可用的" aria-hidden="true">#</a> 有些指令是不可用的</h3><p>在带有<code>FUNCTION(S)</code>标志的函数中，不允许有输入的命令，如<code>WAIT</code>，和带有函数调用的命令，如<code>CALL</code>。</p><p>如果使用它们，就会发生错误。</p><p>不能使用<code>CALL</code>指令，但可以在表达式中调用带有<code>FUNCTION(S)</code>标志的函数。</p><p>也可以用<code>CALLF</code>和<code>CALLFORMF</code>指令调用<code>#FUNCTION(S)</code>。</p><h3 id="不支持函数重载" tabindex="-1"><a class="header-anchor" href="#不支持函数重载" aria-hidden="true">#</a> 不支持函数重载</h3><p>不可能用不同数量或类型的参数调用一个以上的<code>#FUNCTION(S)</code>函数。</p><p>只能定义一个同名的函数，如果定义了多个同名的函数，只有第一个函数是有效的。</p><h3 id="覆盖内置函数" tabindex="-1"><a class="header-anchor" href="#覆盖内置函数" aria-hidden="true">#</a> 覆盖内置函数</h3><p>如果你定义了一个与内置函数同名的函数，你将无法调用该内置函数。</p><p>例如，如果你定义了<code>@ABS</code>，你将无法调用原来的<code>ABS</code>。</p><p>如果一个内置函数被覆盖，Emuera 将在启动时显示一个警告。</p><p>如果一个内置函数被覆盖，它可能无法按预期工作，所以可以通过配置来禁止函数的覆盖。</p><p>对于故意覆盖的情况（不推荐），也有一个配置选项，如果一个函数被覆盖，则不发出警告。</p><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h2><p>带有<code>FUNCTION(S)</code>标志的函数不应该改变除局部变量以外的任何变量。</p><p>改变非局部变量的函数（有副作用的函数）可能会由于短路评估或表达式评估的顺序而改变其行为，如下所述。</p><p>对这些函数的意外调用，例如从调试命令或从调试变量观察窗口，也可能导致非预期的行为。</p><h3 id="短路逻辑导致调用省略" tabindex="-1"><a class="header-anchor" href="#短路逻辑导致调用省略" aria-hidden="true">#</a> 短路逻辑导致调用省略</h3><p>即使表达式中存在一个函数，也可能由于短路逻辑而无法调用。</p><p>例如，下面的脚本在<code>IF</code>语句中调用<code>GET_ASSI_CFLAG</code>，并改变<code>GET_ASSI_CFLAG</code>中的<code>ASSI</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>IF X || GET_ASSI_CFLAG(0)\n  Y = CFLAG:ASSI:2\nENDIF\n\n@GET_ASSI_CFLAG(ARG:0)\n#FUNCTION\n  SIF ASSI &lt; 0\n    ASSI = 0\n  RETURNF CFLAG:ASSI:(ARG:0)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>乍一看，执行<code>Y = CFLAG:ASSI:2</code>时，似乎不可能出现<code>ASSI &lt; 0</code>。</p><p>然而，如果X非零，<code>GET_ASSI_CFLAG</code>由于短路评估而不被执行，当试图评估<code>CFLAG:ASSI:2</code>而<code>ASSI &lt; 0</code>时可能发生错误。</p><h3 id="其结果取决于方程的评估顺序" tabindex="-1"><a class="header-anchor" href="#其结果取决于方程的评估顺序" aria-hidden="true">#</a> 其结果取决于方程的评估顺序</h3><p>变量和函数在表达式中被评估的顺序是未定义的。</p><p>有副作用的函数可能取决于表达式中的函数被调用的顺序。</p><p>请不要写这样的代码。</p><p>对于同一版本的 Emuera，调用顺序将是相同的，但在未来可能会发生变化。</p><p>在下面的脚本中，<code>TARGET</code>在<code>ADDCHARA_CFLAG</code>中被改变：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>X = CFLAG:TARGET:10 + ADDCHARA_CFLAG(0)\n\n@ADDCHARA_CFLAG(ARG)\n#FUNCTION\n  ADDCHARA ARG\n  TARGET = CHARANUM -1\n  RETURNF CFLAG:TARGET:2\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>根据<code>CFLAG:TARGET:10</code>是在<code>ADDCHARA_CFLAG</code>之前还是之后被评估，<code>CFLAG:TARGET:10</code>所指向的变量将会改变。</p><p>因此，这个脚本取决于评价的顺序。</p><p>你不应该在带有<code>FUNCTION(S)</code>标志的函数中赋值给<code>ADDCHARA</code>或<code>TARGET</code>。</p><h3 id="可由调试函数调用" tabindex="-1"><a class="header-anchor" href="#可由调试函数调用" aria-hidden="true">#</a> 可由调试函数调用</h3><p><code>FUNCTION(S)</code>标记的函数不仅可以被<code>*.ERB</code>文件中的脚本动态调用，还可以被调试命令和调试变量观察窗口调用。</p><p>特别是，变量<code>watch</code>将试图频繁地更新其值，并在每次更新时调用该函数。</p><p>有副作用的功能可能会因为这种调用而发生故障。</p>',63);var c=n(a,[["render",function(e,n){return s}]]);export{c as default};
