import{o as e,c as a,a as d}from"./app.1f302d32.js";const c='{"title":"与 Eramaker 的差异","description":"","frontmatter":{},"headers":[{"level":2,"title":"修复错误和不自然的行为","slug":"修复错误和不自然的行为"},{"level":3,"title":"数组的最后一个元素不可用","slug":"数组的最后一个元素不可用"},{"level":3,"title":"单元运算符-的异常","slug":"单元运算符-的异常"},{"level":3,"title":"文件的最后一行不会被读取","slug":"文件的最后一行不会被读取"},{"level":3,"title":"如果数组中存在额外的元素，它们将被忽略","slug":"如果数组中存在额外的元素，它们将被忽略"},{"level":3,"title":"不能使用特定格式的阵列调用","slug":"不能使用特定格式的阵列调用"},{"level":3,"title":"将CSV中的异常数字视为整数","slug":"将csv中的异常数字视为整数"},{"level":3,"title":"不自然的记号工作","slug":"不自然的记号工作"},{"level":2,"title":"与 Eramaker 的其他区别","slug":"与-eramaker-的其他区别"},{"level":3,"title":"如果SIF后面紧接着是空行、注释行等","slug":"如果sif后面紧接着是空行、注释行等"},{"level":3,"title":"如果你省略一个参数，如IF或ELSEIF，会发生什么","slug":"如果你省略一个参数，如if或elseif，会发生什么"},{"level":3,"title":"函数名称允许的字符","slug":"函数名称允许的字符"},{"level":3,"title":"RAND的行为","slug":"rand的行为"},{"level":3,"title":"WAIT的行为","slug":"wait的行为"},{"level":3,"title":"JUMP的行为","slug":"jump的行为"},{"level":3,"title":"CALLNAME的行为","slug":"callname的行为"},{"level":3,"title":"PRINTFORM和其他FORM的格式化","slug":"printform和其他form的格式化"},{"level":3,"title":"EVENT函数的属性","slug":"event函数的属性"},{"level":3,"title":"GameBase.csv 代码的读取方法","slug":"gamebase-csv-代码的读取方法"},{"level":3,"title":"Abl.csv 等的读取方法","slug":"abl-csv-等的读取方法"},{"level":3,"title":"Train.csv 的读取方法","slug":"train-csv-的读取方法"},{"level":3,"title":"CharaXX.csv 的读取方法","slug":"charaxx-csv-的读取方法"},{"level":3,"title":"文件的换行代码","slug":"文件的换行代码"},{"level":2,"title":"未纠正的错误和不自然的行为","slug":"未纠正的错误和不自然的行为"},{"level":3,"title":"读取文件的顺序取决于文件系统","slug":"读取文件的顺序取决于文件系统"},{"level":3,"title":"COUNT是在REPEAT-REND的结尾处添加的","slug":"count是在repeat-rend的结尾处添加的"},{"level":3,"title":"NEXTCOM的行为","slug":"nextcom的行为"},{"level":2,"title":"改变的特征","slug":"改变的特征"},{"level":3,"title":"SP角色","slug":"sp角色"}],"relativePath":"translation/Difference.md","lastUpdated":1631721289590}',r={},o=[d('<h1 id="与-eramaker-的差异" tabindex="-1">与 Eramaker 的差异 <a class="header-anchor" href="#与-eramaker-的差异" aria-hidden="true">#</a></h1><blockquote><p>翻译自原文档：<a href="https://osdn.net/projects/emuera/wiki/diff" target="_blank" rel="noopener noreferrer">https://osdn.net/projects/emuera/wiki/diff</a></p></blockquote><h2 id="修复错误和不自然的行为" tabindex="-1">修复错误和不自然的行为 <a class="header-anchor" href="#修复错误和不自然的行为" aria-hidden="true">#</a></h2><h3 id="数组的最后一个元素不可用" tabindex="-1">数组的最后一个元素不可用 <a class="header-anchor" href="#数组的最后一个元素不可用" aria-hidden="true">#</a></h3><p>在 Eramaker 中，如果数组的最后一个元素不为零，数据将在加载时被销毁。</p><p>这个问题在 Emuera 中不会发生。</p><p>这个问题是由于 Eramaker 没有一个一致的保存和加载规范，而 Emuera 有一个一致的保存规范。</p><p>因此，如果你用 Eramaker 保存，用 Emuera 加载，问题就不会发生，但如果你用 Emuera 保存，用 Eramaker 加载，问题就会再现。</p><h3 id="单元运算符-的异常" tabindex="-1">单元运算符<code>-</code>的异常 <a class="header-anchor" href="#单元运算符-的异常" aria-hidden="true">#</a></h3><p>在 Eramaker 中，存在着诸如-100&lt;0是假的问题。</p><p>这个问题在 Emuera 中不会发生。</p><h3 id="文件的最后一行不会被读取" tabindex="-1">文件的最后一行不会被读取 <a class="header-anchor" href="#文件的最后一行不会被读取" aria-hidden="true">#</a></h3><p>Eramaker 会忽略没有换行代码的行。</p><p>这意味着文件的最后一行在<code>CSV</code>和<code>ERB</code>中都被忽略了。</p><p>Emuera 没有再现这种行为。</p><h3 id="如果数组中存在额外的元素，它们将被忽略" tabindex="-1">如果数组中存在额外的元素，它们将被忽略 <a class="header-anchor" href="#如果数组中存在额外的元素，它们将被忽略" aria-hidden="true">#</a></h3><div class="language-"><pre><code>A:1:2 = 34\n</code></pre></div><p>Eramaker上述表达式将把34分配给<code>A:1</code>。</p><p>Emuera中这是一个错误。</p><h3 id="不能使用特定格式的阵列调用" tabindex="-1">不能使用特定格式的阵列调用 <a class="header-anchor" href="#不能使用特定格式的阵列调用" aria-hidden="true">#</a></h3><p>Eramaker 允许你使用 A:0 和 A:(COUNT+1) 等变量。</p><p>另一方面，双数组变量，如<code>ABL:0:2</code>或<code>TALENT:(COUNT+1):2</code>将导致错误。</p><p>另外，如果你在调用字符串变量时省略了参数，你可能会得到一个错误。</p><p>在 Emuera，这个问题不会发生。</p><p>如果双数组的参数是一个常数或表达式，则不会发生错误，而且可以省略字符串变量的参数。</p><h3 id="将csv中的异常数字视为整数" tabindex="-1">将CSV中的异常数字视为整数 <a class="header-anchor" href="#将csv中的异常数字视为整数" aria-hidden="true">#</a></h3><div class="language-"><pre><code>0,ローター,200\n0xFF,ルーター,200\n</code></pre></div><p>如果在<code>Item.csv</code>中发现上述描述，Eramaker 将把<code>0xFF</code>解释为0，<code>TALENT:0</code>将被定义为一个路由器。</p><p>Emuera 将无法重现这一点，它将给出一个错误并使这个定义无效，<code>TALENT:0</code>将被定义为一个转子。[?]</p><h3 id="不自然的记号工作" tabindex="-1">不自然的记号工作 <a class="header-anchor" href="#不自然的记号工作" aria-hidden="true">#</a></h3><div class="language-"><pre><code>A:0:1:99999 +-RESULTS:0=@=+123|*?=Y\n</code></pre></div><p>上述表达方式在 Eramaker 中起作用。</p><p>Emuera 中这是一个错误。</p><h2 id="与-eramaker-的其他区别" tabindex="-1">与 Eramaker 的其他区别 <a class="header-anchor" href="#与-eramaker-的其他区别" aria-hidden="true">#</a></h2><h3 id="如果sif后面紧接着是空行、注释行等" tabindex="-1">如果SIF后面紧接着是空行、注释行等 <a class="header-anchor" href="#如果sif后面紧接着是空行、注释行等" aria-hidden="true">#</a></h3><div class="language-"><pre><code>SIF 条件文\n  ;コメント\n  PRINT hogehoge\n</code></pre></div><p>Eramaker 总是执行<code>PRINT</code>行，因为它不知道<code>SIF</code>的下一行是一个<code>;注释</code>。</p><p>Emuera 和 Kirikiri 一样，只在条件语句为真时执行 PRINT 行。</p><p>Emuera 将空行和注释行视为根本不存在，并将SIF的下一行识别为<code>PRINT hogehoge</code>。</p><p>另外，尽管 Eramaker 允许<code>IF</code>和<code>REPEAT</code>语句跟在<code>SIF</code>后面，但 Emuera 限制了<code>SIF</code>后面的行数，因为这往往不是作者的意图。</p><h3 id="如果你省略一个参数，如if或elseif，会发生什么" tabindex="-1">如果你省略一个参数，如IF或ELSEIF，会发生什么 <a class="header-anchor" href="#如果你省略一个参数，如if或elseif，会发生什么" aria-hidden="true">#</a></h3><p>在 Eramaker 中，如果<code>IF</code>、<code>ELSEIF</code>或赋值语句的参数被省略，则行为未定义。</p><p>然而，如果省略<code>RETURN</code>参数，结果是<code>RETURN 0</code>。</p><p>Emuera 总是把省略的参数解释为0，所以任何小于<code>IF</code>的参数总是不会被执行，但会有一个警告。</p><h3 id="函数名称允许的字符" tabindex="-1">函数名称允许的字符 <a class="header-anchor" href="#函数名称允许的字符" aria-hidden="true">#</a></h3><p>所有字符，包括符号和双字节字符，都可以在 Eramaker 中使用。</p><p>Emuera 也允许双字节字符，但不允许除_（下划线）以外的符号。</p><p>另外，Emuera 不建议用数字作为函数名称的开头。</p><p>下面的脚本 Eramaker 中可以工作，但在 Emuera 中会导致错误。</p><div class="language-"><pre><code>CALL \\.,)(][+-%* 　@&amp;$\n\n@\\.,)(][+-%* 　@&amp;$\n  PRINTL 调用@\\.,)(][+-%* 　@&amp;$函数。\n  RETURN 0\n</code></pre></div><p>在 Emuera 中，如果一个函数名包含<code>,</code>或<code>(</code>，它就会被误解为一个函数参数。</p><p>另外，如果函数名中含有<code>@</code>或运算符，调用<code>LOCAL@函数名</code>将不能正常工作。</p><p>如果函数名称包含<code>{}</code>或<code>%</code>，对<code>CALLFORM</code>的调用将不工作。</p><p>由于这个原因，Emuera 禁止在函数名称中使用符号，就像许多其他编程语言，如<code>C#</code>和<code>Kirikiri</code>一样。</p><p>从1.721版本开始，这是一个<code>警告Lv 1</code>，而不是一个即时的错误终止警告，但它可能会在某个地方引起非预期的行为。</p><p>另外，如果一个函数名以数字开头，它就不能作为一个可以在表达式中使用的函数被调用。</p><p>这是因为表达式将查看单个字符，以确定它是一个数字、变量还是函数。</p><h3 id="rand的行为" tabindex="-1">RAND的行为 <a class="header-anchor" href="#rand的行为" aria-hidden="true">#</a></h3><div class="language-"><pre><code>A = RAND:X\n</code></pre></div><p>对于 ，如果X是0，Eramaker 返回0。</p><p>否则，它返回（0到32767之间的一个随机数）%（X的绝对值）。</p><p>这个方法即使在X为负数时也能工作，从不返回大于32767的值，并且在X大于1000时有一个不可忽视的偏差。</p><p>Emuera 没有再现这些特征。</p><p>Emuera 返回一个从0~1846744073709551615的随机数%（X）。</p><p>如果X是零或负数，Emuera将报错。</p><p>(这是因为Emuera关注的是返回值的一致性，因为官方描述说 &quot;RAND:A的返回值是0到A-1之间的整数&quot;）。</p><p>另外，X在1到9223372036854775807范围内有效（64位有符号整数的正数范围）。</p><p>如果X小于100万亿，就不会出现偏差。</p><h3 id="wait的行为" tabindex="-1">WAIT的行为 <a class="header-anchor" href="#wait的行为" aria-hidden="true">#</a></h3><p>在 Eramaker 中，执行<code>WAIT</code>指令时没有换行，但按下<code>Enter</code>键时有换行。</p><p>在 Emuera 中，当光标位于一行的中间时，当执行<code>WAIT</code>指令时，会创建一个新的行，但当按下<code>Enter</code>键或左键时则不会。</p><h3 id="jump的行为" tabindex="-1">JUMP的行为 <a class="header-anchor" href="#jump的行为" aria-hidden="true">#</a></h3><p>在 Eramaker 中，你不能从一个用<code>CALL</code>调用的函数中跳跃出来。</p><p>在 Emuera 中，你可以从一个用<code>CALL</code>调用的函数中跳跃出来。</p><p>如果你在<code>JUMP</code>目标中<code>RETURN</code>，行为将与你在<code>JUMP</code>源函数中<code>RETURN</code>相同。</p><div class="language-"><pre><code>CALL FOOBAR\n@FOO\n  PRINTL 函数@FOO\n  JUMP BAR\n@BAR\n  PRINTL 函数@BAR\n  RETURN 0\n@FOOBAR\n  PRINTL 函数@FOOBAR\n  CALL FOO\n  PRINTW 从函数@FOOBAR返回\n</code></pre></div><p>Eramaker 输出：</p><div class="language-"><pre><code>试图用JUMP来调用一个函数，而这个函数是用CALL调用的。\n</code></pre></div><p>Emuera 输出：</p><div class="language-"><pre><code>函数@FOOBAR\n函数@FOO\n函数@BAR\n从函数@FOOBAR返回\n</code></pre></div><h3 id="callname的行为" tabindex="-1">CALLNAME的行为 <a class="header-anchor" href="#callname的行为" aria-hidden="true">#</a></h3><p>在 Eramaker 中，当引用<code>CALLNAME</code>时，如果<code>CALLNAME</code>是一个空字符串，它将返回<code>NAME</code>的值来代替。</p><p>在 Emuera 中，如果<code>CALLNAME</code>是一个空字符串，它将返回一个空字符串。</p><p>为了弥补这一差异，Emuera 提供了<code>如果CALLNAME是一个空字符串，则分配NAME</code>的选项。</p><p>如果这个选项是<code>YES</code>，并且<code>CALLNAME</code>没有在<code>CharaXX.csv</code>中设置，或者设置为空字符串，Emuera 就会假定<code>NAME</code>设置为相同的字符串。</p><p>然而，即使是这个选项也不是完全可重复的。</p><p>例如，如果你用 Eramaker 添加一个角色到保存中，然后用 Emuera 读取，行为可能不同。</p><h3 id="printform和其他form的格式化" tabindex="-1">PRINTFORM和其他FORM的格式化 <a class="header-anchor" href="#printform和其他form的格式化" aria-hidden="true">#</a></h3><p>Eramaker 会根据需要重复多次，直到没有更多的东西需要被格式化。</p><p>如果有自我引用或循环引用，它就会冻结。</p><p>Emuera 只会格式化一次。</p><p>Eramaker 的格式化可能是以下列方式进行的：</p><div class="language-"><pre><code>str = 被格式化的字符串\nwhile(字符串中存在{～～})\n  格式化最左边的{～～}\nwhile(字符串中存在%～～%)\n  格式化最左边的{～～}%～～%\nwhile(字符串中存在***)\n  格式化最左边的***\nwhile(字符串中存在$$$)\n  格式化最左边的$$$\nwhile(字符串中存在+++)\n  格式化最左边的+++\nwhile(字符串中存在///)\n  格式化最左边的///\nwhile(字符串中存在===)\n  格式化最左边的===\n</code></pre></div><p>由于这种行为，Eramaker 还允许你：</p><div class="language-"><pre><code>STR:1 = S1%STR:2%3%4%\nSTR:2 = S2%STR:\nSTR:3 = S3%STR:\nSTR:4 = S4\nPRINTFORMSL STR:1\nPRINTFORML %STR:1%\nDRAWLINE \n;结果\n;S1S2S3S4\n;S1S2S3S4\n</code></pre></div><p>Emuera 不会重现这种情况。</p><h3 id="event函数的属性" tabindex="-1">EVENT函数的属性 <a class="header-anchor" href="#event函数的属性" aria-hidden="true">#</a></h3><p>在 Eramaker 中，对事件函数的调用是以下列方式进行的：</p><div class="language-"><pre><code>foreach(function with #PRI)\n{\n  功能调用\n  if(#SINGLE且返回值为1)\n    break;\n}\nforeach(没有#PRI或#LATER的函数)\n{\n  功能调用\n  if(#SINGLE且返回值为1)\n    break;\n}\nforeach(function with #LATER)\n{\n  功能调用\n  if(#SINGLE且返回值为1)\n    break;\n}\n</code></pre></div><p>一个同时具有<code>#PRI</code>和<code>#LATER</code>的事件函数将被调用两次。</p><p><code>#SINGLE</code>只有在返回值为1的情况下才会中止后续的函数调用。</p><p>另外，<code>#SINGLE</code>中断了每一对带有<code>#PRI</code>或<code>#LATER</code>的函数调用。</p><p>Emuera 自1.800版（1.756alpha018包括开发版）以来，完全再现了这种行为。</p><p>在早期的 Emuera 中，对事件函数的调用是以下列方式进行的：</p><div class="language-"><pre><code>根据#PRI和#LATER对函数列表进行排序\nforeach(所有函数)\n{\n  功能调用\n  if(#SINGLE且返回值为1)\n    break;\n}\n</code></pre></div><p>如果<code>#PRI</code>和<code>#LATER</code>都存在，那么该函数将被视为两者都没有的情况。</p><p>如果函数调用被<code>#SINGLE</code>打断，那么对事件函数的调用将被终止，不管<code>#PRI</code>或<code>#LATER</code>是否存在。</p><p>注意，在 Emuera 1.751b之前，如果返回值为非零，<code>#SINGLE</code>会中止后续的函数调用。</p><p>这个问题在1.752中被修复了，目前的版本只在返回值为1时中止后续的函数调用，就像Eramaker 一样。</p><h3 id="gamebase-csv-代码的读取方法" tabindex="-1">GameBase.csv 代码的读取方法 <a class="header-anchor" href="#gamebase-csv-代码的读取方法" aria-hidden="true">#</a></h3><p>如果你在 GameBase.csv 中输入的数字超过了-2147483648到2147483647的范围，这是 Eramaker 可以处理的范围，Eramaker 将把<code>csv</code>值转换为16进制，并使用最后8位数字作为游戏代码。</p><p>例如，如果你写<code>代码,08231000181818110</code>，游戏代码将是<code>301712126</code>，这是 Eramaker 可以处理的范围。</p><p>Emuera 没有再现这种行为。</p><p>在1.803版之前的 Emuera 中，如果是类似<code>code,08231000181818110</code>的游戏代码，则会是0。</p><p>Emuera 可以处理范围在-9223372036854775808到9223372036854775807的数字，但 <code>GAMEBASE_GAMECODE</code>只能像 Eramaker 一样处理-2147483648到2147483647范围内的数字，如果数字超过这个范围，它将被设置为0。</p><p>此外，在 Emuera 1.804版本中，游戏代码将是8231000181818110，即使是<code>代码，08231000181818110</code>。</p><p>(<code>GAMEBASE_GAMECODE</code>变量已被改变，以处理与其他变量相同的范围) 在这种情况下，如果数值的数量超过了 Emuera 可以处理的数字范围，如 <code>code,98231000181818110110</code>，游戏代码也将为0。</p><p>在 Emuera 1.805或更高版本中，如果保存的数据的游戏代码为0，则无论游戏的游戏代码如何，都可以读取。</p><h3 id="abl-csv-等的读取方法" tabindex="-1">Abl.csv 等的读取方法 <a class="header-anchor" href="#abl-csv-等的读取方法" aria-hidden="true">#</a></h3><p>在 Eramaker 中，你可以指定一个负的或非常大的索引值，如<code>99999:技巧</code>。</p><p>然而，这个数字将用于<code>PRINT_ABL</code>和其他应用程序，因此<code>PRINT_ABL</code>将参考<code>ABL:99999</code>（在 Eramaker 中），并发生错误。</p><p>由于这个原因，实际值与<code>ABL</code>和<code>TALENT</code>数组的数量相同。</p><p>即使在<code>Item.csv</code>中，当提及<code>SHOP</code>中的<code>ITEM</code>或<code>ITEMSALES</code>时，也会出现错误。</p><p>Emuera 不允许你指定<code>ABL</code>等数组范围之外的值。</p><p>这样的线条将被忽略。</p><p>相反，你可以用<code>VariableSize.csv</code>改变阵列的范围。</p><h3 id="train-csv-的读取方法" tabindex="-1">Train.csv 的读取方法 <a class="header-anchor" href="#train-csv-的读取方法" aria-hidden="true">#</a></h3><p>基本上，它与其他任何csv文件相同，但有一些不同之处。</p><p>例如，在 Eramaker 中，如果你定义了<code>XXX,9999</code>，如果<code>@COM99999</code>被定义，命令将被正确执行。</p><p>另一方面，如果你定义了一个负值，如<code>YYY,-2</code>，命令会出现，但当你选择它时，什么也不会发生。</p><p>Emuera 不会重现这种行为。</p><p>可以定义的范围是不超过<code>VariableSize.csv</code>中指定的<code>TRAINNAME</code>的大小，否则将被忽略。</p><p>如果你没有改变<code>TRAINNAME</code>的大小，0-999的范围是有效的。</p><h3 id="charaxx-csv-的读取方法" tabindex="-1">CharaXX.csv 的读取方法 <a class="header-anchor" href="#charaxx-csv-的读取方法" aria-hidden="true">#</a></h3><p>在 Eramaker 中，即使编号小于0或大于1000，<code>ADDCHARA</code>也能正常工作。</p><p>这也是 Emuera 的行为。</p><p>在 Eramaker 中，如果需要第三个值，例如<code>foundation,0</code>，如果省略它，则被视为0。</p><p>另外，如果不需要第三个值，如<code>quality,0,100</code>，它将被忽略并被设置为1。</p><p>Emuera 没有再现这种行为。</p><p>如果你指定<code>基础,0</code>，<code>MAXBASE:0</code>将是1，如果你指定<code>素质,0,100</code>，<code>Talent:0</code>将是100。</p><h3 id="文件的换行代码" tabindex="-1">文件的换行代码 <a class="header-anchor" href="#文件的换行代码" aria-hidden="true">#</a></h3><p>当换行代码为<code>CR``LF</code>和<code>LF</code>时，Eramaker 将其作为一个新行处理。 但是，当换行代码只有<code>CR</code>时，它不被作为一个新行处理，并出现各种故障。</p><p>Emuera 没有重现这种行为，只将<code>CR</code>作为换行处理。</p><h2 id="未纠正的错误和不自然的行为" tabindex="-1">未纠正的错误和不自然的行为 <a class="header-anchor" href="#未纠正的错误和不自然的行为" aria-hidden="true">#</a></h2><h3 id="读取文件的顺序取决于文件系统" tabindex="-1">读取文件的顺序取决于文件系统 <a class="header-anchor" href="#读取文件的顺序取决于文件系统" aria-hidden="true">#</a></h3><p>在 Eramaker basic 中，有些情况下，行为取决于文件的读取顺序，例如，当调用一个多重函数时。</p><p>然而，在 Eramaker 中，文件的读取顺序取决于文件系统，所以可能不会像预期那样工作。</p><p>这个问题也在 Emuera 中重现。</p><p>目前许多可用的脚本假定文件系统是NTFS，如果文件系统是FAT，则不能正确工作。</p><h3 id="count是在repeat-rend的结尾处添加的" tabindex="-1">COUNT是在REPEAT-REND的结尾处添加的 <a class="header-anchor" href="#count是在repeat-rend的结尾处添加的" aria-hidden="true">#</a></h3><p>在 Eramaker 中，当你退出<code>REPEAT</code>-<code>REND</code>时，<code>COUNT</code>会增加1。</p><p>如果你用<code>BREAK</code>退出，计数也是+1。</p><p>Emuera 再现了这种行为。</p><p>在<code>FOR</code>-<code>NEXT</code>语法中，循环变量也是+1。</p><p>请注意，该行为与一般编程语言中的<code>for</code>和<code>break</code>语句不同。</p><h3 id="nextcom的行为" tabindex="-1">NEXTCOM的行为 <a class="header-anchor" href="#nextcom的行为" aria-hidden="true">#</a></h3><p>在 Eramaker 中，<code>NEXTCOM</code>的初始值是-1，但执行<code>NEXTCOM</code>后分配的值是0而不是-1。 这意味着<code>NEXTCOM</code>将不断重复<code>COM0</code>，除非你在ERB中再次指定它。 请注意，在官方 Eramaker 文档中没有提到<code>NEXTCOM</code>。 Emuera 也再现了这种行为。 <code>NEXTCOM</code>功能只是为了与 Eramaker 兼容而复制的，不建议使用它。 如果你的代码不打算在 Eramaker 中运行，考虑使用<code>DOTRAIN</code>或<code>CALLTRAIN</code>指令。</p><h2 id="改变的特征" tabindex="-1">改变的特征 <a class="header-anchor" href="#改变的特征" aria-hidden="true">#</a></h2><h3 id="sp角色" tabindex="-1">SP角色 <a class="header-anchor" href="#sp角色" aria-hidden="true">#</a></h3><p>在 Eramaker 中，csv中<code>CFLAG:0</code>设置为非零的字符是SP角色。</p><p>用<code>ADDCHARA</code>注册一个角色是不可能的，你必须用<code>ADDSPCHARA</code>注册它。</p><p>这也是导致<code>CFLAG:0</code>被无意中设置为非零，无法被<code>ADDCHARA</code>注册的一个错误。</p><p>Emuera 已经决定从1.816版开始不支持这个功能作为标准功能。</p><p><code>CFLAG:0</code>不再被视为特殊，所有的角色都可以从<code>ADDCHARA</code>注册。</p><p>兼容性选项 &quot;使用SP角色 &quot;允许你重现 Eramaker 的行为，但不建议将其用于任何目的，除了使旧的脚本工作。</p>',165)];r.render=function(d,c,r,p,i,n){return e(),a("div",null,o)};export{c as __pageData,r as default};
