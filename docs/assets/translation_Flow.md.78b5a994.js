import{o as e,c as d,a as o}from"./app.1f302d32.js";const c='{"title":"流程图","description":"","frontmatter":{},"headers":[{"level":2,"title":"TITLE","slug":"title"},{"level":2,"title":"FIRST","slug":"first"},{"level":2,"title":"SHOP","slug":"shop"},{"level":2,"title":"TRAIN","slug":"train"},{"level":2,"title":"ABLUP","slug":"ablup"},{"level":2,"title":"AFTERTRAIN","slug":"aftertrain"},{"level":2,"title":"TURNEND","slug":"turnend"},{"level":2,"title":"LOADGAME","slug":"loadgame"},{"level":2,"title":"SAVEGAME","slug":"savegame"},{"level":2,"title":"LOADDATAEND","slug":"loaddataend"}],"relativePath":"translation/Flow.md","lastUpdated":1631548419309}',p={},a=[o('<h1 id="流程图" tabindex="-1">流程图 <a class="header-anchor" href="#流程图" aria-hidden="true">#</a></h1><blockquote><p>翻译自原文档：<a href="https://osdn.net/projects/emuera/wiki/flow" target="_blank" rel="noopener noreferrer">https://osdn.net/projects/emuera/wiki/flow</a></p></blockquote><p>流程图是用DiagramDesigner创建的。</p><p>数据文件在这里。</p><p>在以下描述中，除非另有说明，否则句子的主语是Emuera.exe。</p><h2 id="title" tabindex="-1">TITLE <a class="header-anchor" href="#title" aria-hidden="true">#</a></h2><p>在启动和阅读<code>ERB</code>后，并在运行<code>BEGIN TITLE</code>后。</p><p>如果<code>@SYSTEM_TITLE</code>被定义了，它就会被调用，其他的就不做了。</p><p>如果<code>@SYSTEM_TITLE</code>在没有<code>BEGIN</code>或<code>LOADDATA</code>指令的情况下被<code>RETURN</code>，就没有下一个操作要执行，错误终止。</p><p>如果没有定义<code>@SYSTEM_TITLE</code>，就会使用标准的标题程序。</p><p>标准标题屏幕上的文字，如<code>[0]从头开始</code>，可以被改变。</p><p>详见<a href="./.html">_replace.csv</a>。</p><p>如果选择<code>[0]从头开始</code>，首先要做的是初始化数据。</p><p>具体来说，<code>STR</code>和<code>PRINTLV</code>的初始值被设置（与<code>RESETDATA</code>指令相同），<code>ADDCHARA 0</code>，等等。</p><p>接下来，<code>BEGIN FIRST</code>被执行，并过渡到<code>FIRST</code>。</p><p>如果选择了<code>[1]加载和启动</code>，如果定义了，就会调用<code>@TITLE_LOADGAME</code>。</p><p>如果没有定义，就会显示标准加载屏幕。</p><p>这与<code>@LOADGAME</code>所调用的屏幕略有不同。</p><h2 id="first" tabindex="-1">FIRST <a class="header-anchor" href="#first" aria-hidden="true">#</a></h2><p>当在标题屏幕上选择了<code>[0]从头开始</code>，并且在执行了<code>BEGIN FIRST</code>之后。</p><p>如果在<code>@EVENTFIRST</code>中没有执行<code>BEGIN</code>指令，就没有下一个要执行的进程，错误结束。</p><h2 id="shop" tabindex="-1">SHOP <a class="header-anchor" href="#shop" aria-hidden="true">#</a></h2><p>在加载和运行<code>BEGIN SHOP</code>后。</p><p>如果在加载后，<code>@EVENTSHOP</code>未被处理。</p><p>在<code>@SHOW_SHOP</code>调用之后，要求输入。如果输入是0-99，则处理购买，否则就调用<code>@USERSHOP</code>。 这个范围可以在<code>_replace.csv</code>中改变。 详见<a href="./.html">_replace.csv</a>。</p><p>请注意，<code>@PRINT_ITEMSHOP</code>指令显示的项目范围是<code>ITEMNAME</code>或<code>ITEMSALES</code>中的元素数，以小者为准（标准是1000）。</p><p>当购买过程被调用时，要确定相应的<code>ITEMSALES</code>是否为非零，或者MONEY是否大于<code>ITEMPRICE</code>。</p><p>如果购买决策失败，则要求再次输入。</p><p>在 Eramaker 中，如果购买失败，用户必须从<code>@SHOW_SHOP</code>重新开始。</p><p>如果购买决策成功，将<code>ITEM</code>编号分配给<code>BOUGHT</code>变量，将<code>ITEM:BOUGHT</code>增加1，并通过<code>ITEMPRICE:BOUGHT</code>减少<code>MONEY</code>。</p><p>呼叫<code>@EVENTBUY</code>，返回<code>@SHOW_SHOP</code>。</p><p>除非在某个地方发出<code>BEGIN</code>指令，否则你永远不会离开<code>SHOP</code>。</p><h2 id="train" tabindex="-1">TRAIN <a class="header-anchor" href="#train" aria-hidden="true">#</a></h2><p>在执行<code>BEGIN TRAIN</code>后。</p><p>首先，一些变量会被初始化。</p><p>具体来说，将0分配给<code>ASSIPLAY:0</code>，-1分配给<code>PREVCOM:0</code>，-1分配给<code>NEXTCOM:0</code>。</p><p>此外，<code>TFLAG</code>被设置为0，<code>GOTJUEL</code>、<code>TEQUIP</code>、<code>EX</code>、<code>PALAM</code>和<code>SOURCE</code>的所有字符都被设置为0。</p><p>最后，为所有字符的<code>STAIN:2</code>分配2，为<code>STAIN:3</code>分配1，为<code>STAIN:4</code>分配8，为其他分配0。</p><p>当你离开训练流程时，这些值不会被初始化，所以如果你在商店里保存，这些值会保留在你的保存数据中。</p><p>你可以通过<code>@SAVEINFO</code>或其他方法将角色的<code>GOTJUEL</code>、<code>TEQUIP</code>、<code>EX</code>、<code>PALAM</code>等指定为0来保存保存数据的大小。</p><p>这里不解释<code>NEXTCOM</code>的非负值的行为，因为它有一个严重的错误。</p><p>Emuera的<code>NEXTCOM</code>是为了重现旧代码的行为而实施的，包括上述的缺陷，并不打算用于新的用途。</p><p>关于<code>CALLTRAIN</code>指令，见<a href="./.html">扩展</a>。</p><p>显示调用<code>@SHOW_STATUS</code>后可执行的<code>TRAIN</code>。</p><p>搜索<code>@COM_ABLExx</code>，寻找那些有定义的<code>TRAINNAME</code>。</p><p>搜索范围（图中的<code>MAX_TRAIN</code>）对于Emuera来说是到<code>VariableSize.csv</code>中指定的<code>TRAINNAME</code>范围，对于 Eramaker 来说是到2147483647。</p><p>如果<code>@COM_ABLExx</code>没有被定义或返回非零值，那么它就是可执行的，<code>TRAINNAME</code>被打印出来。</p><p>如果<code>@COM_ABLExx</code>返回0，则不能执行，不显示<code>TRAINNAME</code>。</p><p>在这个时候，它记住了是否可执行。 (这并不意味着<code>@COM_ABLExx</code>在运行时被再次调用）。</p><p>显示<code>TRAINNAME</code>后，调用<code>@SHOW_USERCOM</code>。</p><p>在<code>@SHOW_USERCOM</code>之后，输入前初始化<code>UP</code>、<code>DOWN</code>和<code>LOSEBASE</code>。</p><p>之后，要求输入。</p><p>输入的结果与<code>@COM_ABLExx</code>的结果进行核对，如果该命令是可执行的，则调用相应的<code>@COMxx</code>。</p><p>首先，<code>TRAIN</code>号被分配给<code>SELECTCOM</code>变量，所有字符的<code>NOWEX</code>的所有元素被设置为0。</p><p>接下来，<code>@EVENTCOM</code>被调用，接着是相应的<code>@COM</code>。</p><p>如果<code>@COM</code>返回一个非零值，则调用<code>@SOURCE_CHECK</code>、<code>@EVENTCOMEND</code>并返回<code>@SHOW_STATUS</code>。</p><p>在<code>@SOURCE_CHECK</code>完成后，在调用<code>@EVENTCOMEND</code>前，将所有字符的<code>SOURCE</code>的所有元素设置为0。</p><p>如果在<code>@SOURCE_CHECK</code>之后，<code>@EVENTCOMEND</code>不存在或者在<code>@EVENTCOMEND</code>中没有给出WAIT指令，那么在<code>@SHOW_STATUS</code>之前就会产生一个<code>WAIT</code>。</p><p>如果<code>@COM</code>返回0，则返回到<code>@SHOW_STATUS</code>。</p><p>注意，当<code>UPCHECK</code>指令被执行时，<code>UP</code>和<code>DOWN</code>的值与<code>TARGET</code>的<code>PALAM</code>相加和相减，并且<code>UP</code>和<code>DOWN</code>的值都被分配为0。</p><p>如果输入的结果不是可执行的命令，则调用<code>@USERCOM</code>并返回<code>@SHOW_STATUS</code>。</p><p>除非在某个地方发出<code>BEGIN</code>命令，否则你永远不会离开<code>TRAIN</code>。</p><h2 id="ablup" tabindex="-1">ABLUP <a class="header-anchor" href="#ablup" aria-hidden="true">#</a></h2><p>在执行了<code>BEGIN ABLUP</code>之后。</p><p>调用<code>@SHOW_JUEL</code>和<code>@SHOW_ABLUP_SELECT</code>来请求输入。</p><p>如果输入的范围是0-99，找到相应的<code>@ABLUP</code>。</p><p>如果定义了相应的<code>@ABLUP</code>，则调用<code>@ABLUP</code>并返回到<code>@SHOW_JUEL</code>。</p><p>如果没有定义，就会再次要求输入。</p><p>在 Eramaker 中，如果没有定义，就从<code>@SHOW_JUEL</code>重新开始。</p><p>如果输入值在0-99范围之外，则调用<code>@USERABLUP</code>并返回<code>@SHOW_JUEL</code>。</p><p>从Emuera 1.705开始，没有办法改变这个范围。</p><p>除非在某处给出<code>BEGIN</code>指令，否则你永远无法从<code>ABLUP</code>中出来。</p><h2 id="aftertrain" tabindex="-1">AFTERTRAIN <a class="header-anchor" href="#aftertrain" aria-hidden="true">#</a></h2><p>在执行<code>BEGIN AFTERTRAIN</code>后。</p><p>如果在<code>@EVENTEND</code>内没有执行<code>BEGIN</code>指令，就没有下一个进程可以执行，错误结束。</p><h2 id="turnend" tabindex="-1">TURNEND <a class="header-anchor" href="#turnend" aria-hidden="true">#</a></h2><p>在执行了<code>@BEGIN TURNEND</code>之后。</p><p>如果在<code>@EVENTTURNEND</code>内没有执行<code>BEGIN</code>指令，就没有下一个进程可以执行，错误结束。</p><h2 id="loadgame" tabindex="-1">LOADGAME <a class="header-anchor" href="#loadgame" aria-hidden="true">#</a></h2><p>当执行<code>LOADGAME</code>指令时。</p><p><code>BEGIN</code>指令包含<code>RETURN</code>指令，<code>BEGIN</code>下面的语句从不执行，但<code>LOADDATA</code>和<code>SAVEDATA</code>指令与<code>CALL</code>指令一样返回原处。</p><p>然而，当<code>LOAD</code>被执行时，它就会忘记原来的位置并过渡到<code>LOADDATAEND</code>。</p><h2 id="savegame" tabindex="-1">SAVEGAME <a class="header-anchor" href="#savegame" aria-hidden="true">#</a></h2><p>当<code>@SAVEGAME</code>指令被执行时。</p><p>调用<code>@SAVEINFO</code>的时机是在实际写完之前。</p><h2 id="loaddataend" tabindex="-1">LOADDATAEND <a class="header-anchor" href="#loaddataend" aria-hidden="true">#</a></h2><p>在<code>LOADGAME</code>中执行了<code>LOAD</code>后，在执行了<code>LOADDATA</code>指令后。</p><p>当执行<code>LOAD</code>时，所有以前的状态，包括被调用的函数，都被擦除。</p><p>Eramaker 在这里什么都不做，就过渡到<code>@SHOW_SHOP</code>。</p><p>在 Emuera 中，如果<code>@SYSTEM_LOADEND</code>被定义，<code>@SYSTEM_LOADEND</code>将被执行。</p><p>如果<code>BEGIN</code>指令在<code>@SYSTEM_LOADEND</code>结束之前被执行，它就会过渡到那里。</p><p>否则，如果定义了<code>@EVENTLOAD</code>，<code>就会执行@EVENTLOAD</code>。</p><p>如果<code>BEGIN</code>指令在<code>@EVENTLOAD</code>结束前被执行，它就会向该方向移动。</p><p>如果<code>BEGIN</code>指令没有被执行，则照常过渡到<code>@SHOW_SHOP</code>。</p>',94)];p.render=function(o,c,p,E,A,T){return e(),d("div",null,a)};export{c as __pageData,p as default};
