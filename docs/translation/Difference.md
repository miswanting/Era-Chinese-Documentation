# 与 Eramaker 的差异

> 翻译自原文档：https://osdn.net/projects/emuera/wiki/diff

## 修复错误和不自然的行为

### 数组的最后一个元素不可用

在 Eramaker 中，如果数组的最后一个元素不为零，数据将在加载时被销毁。

这个问题在 Emuera 中不会发生。

这个问题是由于 Eramaker 没有一个一致的保存和加载规范，而 Emuera 有一个一致的保存规范。

因此，如果你用 Eramaker 保存，用 Emuera 加载，问题就不会发生，但如果你用 Emuera 保存，用 Eramaker 加载，问题就会再现。

### 单元运算符`-`的异常

在 Eramaker 中，存在着诸如-100<0是假的问题。

这个问题在 Emuera 中不会发生。

### 文件的最后一行不会被读取

Eramaker 会忽略没有换行代码的行。

这意味着文件的最后一行在`CSV`和`ERB`中都被忽略了。

Emuera 没有再现这种行为。

### 如果数组中存在额外的元素，它们将被忽略

```
A:1:2 = 34
```

Eramaker上述表达式将把34分配给`A:1`。

Emuera中这是一个错误。

### 不能使用特定格式的阵列调用

Eramaker 允许你使用 A:0 和 A:(COUNT+1) 等变量。

另一方面，双数组变量，如`ABL:0:2`或`TALENT:(COUNT+1):2`将导致错误。

另外，如果你在调用字符串变量时省略了参数，你可能会得到一个错误。

在 Emuera，这个问题不会发生。

如果双数组的参数是一个常数或表达式，则不会发生错误，而且可以省略字符串变量的参数。

### 将CSV中的异常数字视为整数

```
0,ローター,200
0xFF,ルーター,200
```

如果在`Item.csv`中发现上述描述，Eramaker 将把`0xFF`解释为0，`TALENT:0`将被定义为一个路由器。

Emuera 将无法重现这一点，它将给出一个错误并使这个定义无效，`TALENT:0`将被定义为一个转子。[?]

### 不自然的记号工作

```
A:0:1:99999 +-RESULTS:0=@=+123|*?=Y
```

上述表达方式在 Eramaker 中起作用。

Emuera 中这是一个错误。

## 与 Eramaker 的其他区别

### 如果SIF后面紧接着是空行、注释行等

```
SIF 条件文
  ;コメント
  PRINT hogehoge
```

Eramaker 总是执行`PRINT`行，因为它不知道`SIF`的下一行是一个`;注释`。

Emuera 和 Kirikiri 一样，只在条件语句为真时执行 PRINT 行。

Emuera 将空行和注释行视为根本不存在，并将SIF的下一行识别为`PRINT hogehoge`。

另外，尽管 Eramaker 允许`IF`和`REPEAT`语句跟在`SIF`后面，但 Emuera 限制了`SIF`后面的行数，因为这往往不是作者的意图。

### 如果你省略一个参数，如IF或ELSEIF，会发生什么

在 Eramaker 中，如果`IF`、`ELSEIF`或赋值语句的参数被省略，则行为未定义。

然而，如果省略`RETURN`参数，结果是`RETURN 0`。

Emuera 总是把省略的参数解释为0，所以任何小于`IF`的参数总是不会被执行，但会有一个警告。

### 函数名称允许的字符

所有字符，包括符号和双字节字符，都可以在 Eramaker 中使用。

Emuera 也允许双字节字符，但不允许除_（下划线）以外的符号。

另外，Emuera 不建议用数字作为函数名称的开头。

下面的脚本 Eramaker 中可以工作，但在 Emuera 中会导致错误。

```
CALL \.,)(][+-%* 　@&$

@\.,)(][+-%* 　@&$
  PRINTL 调用@\.,)(][+-%* 　@&$函数。
  RETURN 0
```

在 Emuera 中，如果一个函数名包含`,`或`(`，它就会被误解为一个函数参数。

另外，如果函数名中含有`@`或运算符，调用`LOCAL@函数名`将不能正常工作。

如果函数名称包含`{}`或`%`，对`CALLFORM`的调用将不工作。

由于这个原因，Emuera 禁止在函数名称中使用符号，就像许多其他编程语言，如`C#`和`Kirikiri`一样。

从1.721版本开始，这是一个`警告Lv 1`，而不是一个即时的错误终止警告，但它可能会在某个地方引起非预期的行为。

另外，如果一个函数名以数字开头，它就不能作为一个可以在表达式中使用的函数被调用。

这是因为表达式将查看单个字符，以确定它是一个数字、变量还是函数。

### RAND的行为

```
A = RAND:X
```

对于 ，如果X是0，Eramaker 返回0。

否则，它返回（0到32767之间的一个随机数）%（X的绝对值）。

这个方法即使在X为负数时也能工作，从不返回大于32767的值，并且在X大于1000时有一个不可忽视的偏差。

Emuera 没有再现这些特征。

Emuera 返回一个从0~1846744073709551615的随机数%（X）。

如果X是零或负数，Emuera将报错。

(这是因为Emuera关注的是返回值的一致性，因为官方描述说 "RAND:A的返回值是0到A-1之间的整数"）。

另外，X在1到9223372036854775807范围内有效（64位有符号整数的正数范围）。

如果X小于100万亿，就不会出现偏差。

### WAIT的行为

在 Eramaker 中，执行`WAIT`指令时没有换行，但按下`Enter`键时有换行。

在 Emuera 中，当光标位于一行的中间时，当执行`WAIT`指令时，会创建一个新的行，但当按下`Enter`键或左键时则不会。

### JUMP的行为

在 Eramaker 中，你不能从一个用`CALL`调用的函数中跳跃出来。

在 Emuera 中，你可以从一个用`CALL`调用的函数中跳跃出来。

如果你在`JUMP`目标中`RETURN`，行为将与你在`JUMP`源函数中`RETURN`相同。

```
CALL FOOBAR
@FOO
  PRINTL 函数@FOO
  JUMP BAR
@BAR
  PRINTL 函数@BAR
  RETURN 0
@FOOBAR
  PRINTL 函数@FOOBAR
  CALL FOO
  PRINTW 从函数@FOOBAR返回
```

Eramaker 输出：

```
试图用JUMP来调用一个函数，而这个函数是用CALL调用的。
```

Emuera 输出：

```
函数@FOOBAR
函数@FOO
函数@BAR
从函数@FOOBAR返回
```

### CALLNAME的行为

在 Eramaker 中，当引用`CALLNAME`时，如果`CALLNAME`是一个空字符串，它将返回`NAME`的值来代替。

在 Emuera 中，如果`CALLNAME`是一个空字符串，它将返回一个空字符串。

为了弥补这一差异，Emuera 提供了`如果CALLNAME是一个空字符串，则分配NAME`的选项。

如果这个选项是`YES`，并且`CALLNAME`没有在`CharaXX.csv`中设置，或者设置为空字符串，Emuera 就会假定`NAME`设置为相同的字符串。

然而，即使是这个选项也不是完全可重复的。

例如，如果你用 Eramaker 添加一个角色到保存中，然后用 Emuera 读取，行为可能不同。

### PRINTFORM和其他FORM的格式化

Eramaker 会根据需要重复多次，直到没有更多的东西需要被格式化。

如果有自我引用或循环引用，它就会冻结。

Emuera 只会格式化一次。

Eramaker 的格式化可能是以下列方式进行的：

```
str = 被格式化的字符串
while(字符串中存在{～～})
  格式化最左边的{～～}
while(字符串中存在%～～%)
  格式化最左边的{～～}%～～%
while(字符串中存在***)
  格式化最左边的***
while(字符串中存在$$$)
  格式化最左边的$$$
while(字符串中存在+++)
  格式化最左边的+++
while(字符串中存在///)
  格式化最左边的///
while(字符串中存在===)
  格式化最左边的===
```

由于这种行为，Eramaker 还允许你：

```
STR:1 = S1%STR:2%3%4%
STR:2 = S2%STR:
STR:3 = S3%STR:
STR:4 = S4
PRINTFORMSL STR:1
PRINTFORML %STR:1%
DRAWLINE 
;结果
;S1S2S3S4
;S1S2S3S4
```

Emuera 不会重现这种情况。

### EVENT函数的属性

在 Eramaker 中，对事件函数的调用是以下列方式进行的：

```
foreach(function with #PRI)
{
  功能调用
  if(#SINGLE且返回值为1)
    break;
}
foreach(没有#PRI或#LATER的函数)
{
  功能调用
  if(#SINGLE且返回值为1)
    break;
}
foreach(function with #LATER)
{
  功能调用
  if(#SINGLE且返回值为1)
    break;
}
```

一个同时具有`#PRI`和`#LATER`的事件函数将被调用两次。

`#SINGLE`只有在返回值为1的情况下才会中止后续的函数调用。

另外，`#SINGLE`中断了每一对带有`#PRI`或`#LATER`的函数调用。

Emuera 自1.800版（1.756alpha018包括开发版）以来，完全再现了这种行为。

在早期的 Emuera 中，对事件函数的调用是以下列方式进行的：

```
根据#PRI和#LATER对函数列表进行排序
foreach(所有函数)
{
  功能调用
  if(#SINGLE且返回值为1)
    break;
}
```

如果`#PRI`和`#LATER`都存在，那么该函数将被视为两者都没有的情况。

如果函数调用被`#SINGLE`打断，那么对事件函数的调用将被终止，不管`#PRI`或`#LATER`是否存在。

注意，在 Emuera 1.751b之前，如果返回值为非零，`#SINGLE`会中止后续的函数调用。

这个问题在1.752中被修复了，目前的版本只在返回值为1时中止后续的函数调用，就像Eramaker 一样。

### GameBase.csv 代码的读取方法

如果你在 GameBase.csv 中输入的数字超过了-2147483648到2147483647的范围，这是 Eramaker 可以处理的范围，Eramaker 将把`csv`值转换为16进制，并使用最后8位数字作为游戏代码。

例如，如果你写`代码,08231000181818110`，游戏代码将是`301712126`，这是 Eramaker 可以处理的范围。

Emuera 没有再现这种行为。

在1.803版之前的 Emuera 中，如果是类似`code,08231000181818110`的游戏代码，则会是0。

Emuera 可以处理范围在-9223372036854775808到9223372036854775807的数字，但
`GAMEBASE_GAMECODE`只能像 Eramaker 一样处理-2147483648到2147483647范围内的数字，如果数字超过这个范围，它将被设置为0。

此外，在 Emuera 1.804版本中，游戏代码将是8231000181818110，即使是`代码，08231000181818110`。

(`GAMEBASE_GAMECODE`变量已被改变，以处理与其他变量相同的范围)
在这种情况下，如果数值的数量超过了 Emuera 可以处理的数字范围，如 `code,98231000181818110110`，游戏代码也将为0。

在 Emuera 1.805或更高版本中，如果保存的数据的游戏代码为0，则无论游戏的游戏代码如何，都可以读取。

### Abl.csv 等的读取方法

在 Eramaker 中，你可以指定一个负的或非常大的索引值，如`99999:技巧`。

然而，这个数字将用于`PRINT_ABL`和其他应用程序，因此`PRINT_ABL`将参考`ABL:99999`（在 Eramaker 中），并发生错误。

由于这个原因，实际值与`ABL`和`TALENT`数组的数量相同。

即使在`Item.csv`中，当提及`SHOP`中的`ITEM`或`ITEMSALES`时，也会出现错误。

Emuera 不允许你指定`ABL`等数组范围之外的值。

这样的线条将被忽略。

相反，你可以用`VariableSize.csv`改变阵列的范围。

### Train.csv 的读取方法

基本上，它与其他任何csv文件相同，但有一些不同之处。

例如，在 Eramaker 中，如果你定义了`XXX,9999`，如果`@COM99999`被定义，命令将被正确执行。

另一方面，如果你定义了一个负值，如`YYY,-2`，命令会出现，但当你选择它时，什么也不会发生。

Emuera 不会重现这种行为。

可以定义的范围是不超过`VariableSize.csv`中指定的`TRAINNAME`的大小，否则将被忽略。

如果你没有改变`TRAINNAME`的大小，0-999的范围是有效的。

### CharaXX.csv 的读取方法

在 Eramaker 中，即使编号小于0或大于1000，`ADDCHARA`也能正常工作。

这也是 Emuera 的行为。

在 Eramaker 中，如果需要第三个值，例如`foundation,0`，如果省略它，则被视为0。

另外，如果不需要第三个值，如`quality,0,100`，它将被忽略并被设置为1。

Emuera 没有再现这种行为。

如果你指定`基础,0`，`MAXBASE:0`将是1，如果你指定`素质,0,100`，`Talent:0`将是100。

### 文件的换行代码

当换行代码为`CR``LF`和`LF`时，Eramaker 将其作为一个新行处理。 但是，当换行代码只有`CR`时，它不被作为一个新行处理，并出现各种故障。

Emuera 没有重现这种行为，只将`CR`作为换行处理。

## 未纠正的错误和不自然的行为

### 读取文件的顺序取决于文件系统

在 Eramaker basic 中，有些情况下，行为取决于文件的读取顺序，例如，当调用一个多重函数时。

然而，在 Eramaker 中，文件的读取顺序取决于文件系统，所以可能不会像预期那样工作。

这个问题也在 Emuera 中重现。

目前许多可用的脚本假定文件系统是NTFS，如果文件系统是FAT，则不能正确工作。

### COUNT是在REPEAT-REND的结尾处添加的

在 Eramaker 中，当你退出`REPEAT`-`REND`时，`COUNT`会增加1。

如果你用`BREAK`退出，计数也是+1。

Emuera 再现了这种行为。

在`FOR`-`NEXT`语法中，循环变量也是+1。

请注意，该行为与一般编程语言中的`for`和`break`语句不同。

### NEXTCOM的行为

在 Eramaker 中，`NEXTCOM`的初始值是-1，但执行`NEXTCOM`后分配的值是0而不是-1。
这意味着`NEXTCOM`将不断重复`COM0`，除非你在ERB中再次指定它。
请注意，在官方 Eramaker 文档中没有提到`NEXTCOM`。
Emuera 也再现了这种行为。
`NEXTCOM`功能只是为了与 Eramaker 兼容而复制的，不建议使用它。
如果你的代码不打算在 Eramaker 中运行，考虑使用`DOTRAIN`或`CALLTRAIN`指令。

## 改变的特征

### SP角色

在 Eramaker 中，csv中`CFLAG:0`设置为非零的字符是SP角色。

用`ADDCHARA`注册一个角色是不可能的，你必须用`ADDSPCHARA`注册它。

这也是导致`CFLAG:0`被无意中设置为非零，无法被`ADDCHARA`注册的一个错误。

Emuera 已经决定从1.816版开始不支持这个功能作为标准功能。

`CFLAG:0`不再被视为特殊，所有的角色都可以从`ADDCHARA`注册。

兼容性选项 "使用SP角色 "允许你重现 Eramaker 的行为，但不建议将其用于任何目的，除了使旧的脚本工作。

